name: Self-Healing Infrastructure

on:
  workflow_dispatch:
    inputs:
      issue_type:
        description: 'Type of issue to remediate'
        required: true
        type: choice
        options:
          - state-lock
          - failed-deployment
          - resource-health
          - all
      environment:
        description: 'Target environment'
        required: false
        type: choice
        options:
          - all
          - dev
          - staging
          - prod
        default: all
  
  # Triggered by monitoring alerts
  repository_dispatch:
    types: [infrastructure-alert]

concurrency:
  group: self-healing-${{ github.event.inputs.environment || 'all' }}
  cancel-in-progress: false

env:
  TERRAFORM_VERSION: '1.5.7'
  TERRAGRUNT_VERSION: '0.52.0'
  MAX_RETRY_ATTEMPTS: 3
  LOCK_TIMEOUT_HOURS: 2

jobs:
  diagnose-issues:
    name: Diagnose Infrastructure Issues
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      issues_found: ${{ steps.diagnose.outputs.issues_found }}
      state_locks: ${{ steps.diagnose.outputs.state_locks }}
      failed_resources: ${{ steps.diagnose.outputs.failed_resources }}
      unhealthy_resources: ${{ steps.diagnose.outputs.unhealthy_resources }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup GCP Authentication
        uses: ./.github/actions/setup-gcp
        with:
          auth-method: ${{ secrets.WIF_PROVIDER && 'workload-identity' || 'service-account' }}
          wif-provider: ${{ secrets.WIF_PROVIDER }}
          wif-service-account: ${{ secrets.WIF_SERVICE_ACCOUNT }}
          service-account-key: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
          project-id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Diagnose Issues
        id: diagnose
        run: |
          echo "## Diagnosing Infrastructure Issues" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          ISSUES_FOUND=false
          STATE_LOCKS=""
          FAILED_RESOURCES=""
          UNHEALTHY_RESOURCES=""
          
          # Check for state locks
          if [ "${{ github.event.inputs.issue_type }}" = "state-lock" ] || [ "${{ github.event.inputs.issue_type }}" = "all" ]; then
            echo "### Checking for state locks..." >> $GITHUB_STEP_SUMMARY
            
            for env in dev staging prod; do
              if [ "${{ github.event.inputs.environment }}" != "all" ] && [ "${{ github.event.inputs.environment }}" != "$env" ]; then
                continue
              fi
              
              # Check if state is locked
              LOCK_INFO=$(gsutil cat gs://${{ secrets.STATE_BUCKET }}/infrastructure/environments/${env}/default.tflock 2>/dev/null || echo "")
              
              if [ -n "$LOCK_INFO" ]; then
                LOCK_TIME=$(echo "$LOCK_INFO" | jq -r '.Created' 2>/dev/null || echo "unknown")
                CURRENT_TIME=$(date +%s)
                
                if [ "$LOCK_TIME" != "unknown" ]; then
                  LOCK_TIMESTAMP=$(date -d "$LOCK_TIME" +%s 2>/dev/null || echo "0")
                  LOCK_AGE_HOURS=$(( (CURRENT_TIME - LOCK_TIMESTAMP) / 3600 ))
                  
                  if [ $LOCK_AGE_HOURS -gt ${{ env.LOCK_TIMEOUT_HOURS }} ]; then
                    echo "‚ö†Ô∏è Stale lock found in ${env}: Locked for ${LOCK_AGE_HOURS} hours" >> $GITHUB_STEP_SUMMARY
                    STATE_LOCKS="${STATE_LOCKS}${env},"
                    ISSUES_FOUND=true
                  fi
                fi
              fi
            done
          fi
          
          # Check for failed deployments
          if [ "${{ github.event.inputs.issue_type }}" = "failed-deployment" ] || [ "${{ github.event.inputs.issue_type }}" = "all" ]; then
            echo "### Checking for failed deployments..." >> $GITHUB_STEP_SUMMARY
            
            # Query recent workflow runs
            FAILED_RUNS=$(gh run list --workflow=terraform-pipeline.yml --status=failure --limit=5 --json conclusion,createdAt,displayTitle | jq -r '.[] | select(.conclusion=="failure")')
            
            if [ -n "$FAILED_RUNS" ]; then
              echo "‚ö†Ô∏è Recent failed deployments detected" >> $GITHUB_STEP_SUMMARY
              FAILED_RESOURCES="deployment-failures"
              ISSUES_FOUND=true
            fi
          fi
          
          # Check resource health
          if [ "${{ github.event.inputs.issue_type }}" = "resource-health" ] || [ "${{ github.event.inputs.issue_type }}" = "all" ]; then
            echo "### Checking resource health..." >> $GITHUB_STEP_SUMMARY
            
            for env in dev staging prod; do
              if [ "${{ github.event.inputs.environment }}" != "all" ] && [ "${{ github.event.inputs.environment }}" != "$env" ]; then
                continue
              fi
              
              # Check GKE cluster health
              if gcloud container clusters describe ${env}-us-central1-gke \
                --zone=us-central1-a \
                --project=${{ secrets.GCP_PROJECT_ID }} \
                --format="value(status)" 2>/dev/null | grep -v "RUNNING"; then
                echo "‚ö†Ô∏è GKE cluster unhealthy in ${env}" >> $GITHUB_STEP_SUMMARY
                UNHEALTHY_RESOURCES="${UNHEALTHY_RESOURCES}${env}-gke,"
                ISSUES_FOUND=true
              fi
              
              # Check Cloud SQL instances
              UNHEALTHY_SQL=$(gcloud sql instances list \
                --project=${{ secrets.GCP_PROJECT_ID }} \
                --filter="name:${env}-* AND state!=RUNNABLE" \
                --format="value(name)" 2>/dev/null)
              
              if [ -n "$UNHEALTHY_SQL" ]; then
                echo "‚ö†Ô∏è Unhealthy Cloud SQL instances in ${env}: ${UNHEALTHY_SQL}" >> $GITHUB_STEP_SUMMARY
                UNHEALTHY_RESOURCES="${UNHEALTHY_RESOURCES}${env}-sql,"
                ISSUES_FOUND=true
              fi
            done
          fi
          
          echo "issues_found=${ISSUES_FOUND}" >> $GITHUB_OUTPUT
          echo "state_locks=${STATE_LOCKS%,}" >> $GITHUB_OUTPUT
          echo "failed_resources=${FAILED_RESOURCES}" >> $GITHUB_OUTPUT
          echo "unhealthy_resources=${UNHEALTHY_RESOURCES%,}" >> $GITHUB_OUTPUT
          
          if [ "$ISSUES_FOUND" = "false" ]; then
            echo "‚úÖ No issues found" >> $GITHUB_STEP_SUMMARY
          fi

  fix-state-locks:
    name: Fix State Locks
    needs: diagnose-issues
    if: needs.diagnose-issues.outputs.state_locks != ''
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform and Terragrunt
        uses: ./.github/actions/setup-terraform

      - name: Setup GCP Authentication
        uses: ./.github/actions/setup-gcp
        with:
          auth-method: ${{ secrets.WIF_PROVIDER && 'workload-identity' || 'service-account' }}
          wif-provider: ${{ secrets.WIF_PROVIDER }}
          wif-service-account: ${{ secrets.WIF_SERVICE_ACCOUNT }}
          service-account-key: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
          project-id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Force Unlock State
        run: |
          LOCKED_ENVS="${{ needs.diagnose-issues.outputs.state_locks }}"
          IFS=',' read -ra ENVS <<< "$LOCKED_ENVS"
          
          for env in "${ENVS[@]}"; do
            echo "Attempting to unlock state for ${env}..."
            
            # Check if any workflows are currently running for this environment
            RUNNING_WORKFLOWS=$(gh run list --workflow=terraform-pipeline.yml --status=in_progress --json displayTitle | jq -r ".[].displayTitle" | grep -c "${env}" || echo "0")
            
            if [ "$RUNNING_WORKFLOWS" -eq 0 ]; then
              cd infrastructure/environments/${env}
              
              # Get lock ID
              LOCK_ID=$(gsutil cat gs://${{ secrets.STATE_BUCKET }}/infrastructure/environments/${env}/default.tflock 2>/dev/null | jq -r '.ID' || echo "")
              
              if [ -n "$LOCK_ID" ]; then
                echo "Force unlocking state with ID: ${LOCK_ID}"
                terragrunt force-unlock -force ${LOCK_ID} || true
                
                # Verify unlock
                if ! gsutil stat gs://${{ secrets.STATE_BUCKET }}/infrastructure/environments/${env}/default.tflock 2>/dev/null; then
                  echo "‚úÖ Successfully unlocked state for ${env}"
                else
                  echo "‚ö†Ô∏è Failed to unlock state for ${env}"
                fi
              fi
              
              cd -
            else
              echo "‚è≠Ô∏è Skipping ${env} - active workflows detected"
            fi
          done

      - name: Create Issue for Manual Review
        if: failure()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'üîí Failed to Auto-Fix State Locks',
              body: `State lock auto-remediation failed for: ${{ needs.diagnose-issues.outputs.state_locks }}
              
              **Run ID:** ${context.runId}
              **Manual intervention required**
              
              Please manually check and unlock the state if necessary.`,
              labels: ['self-healing', 'state-lock', 'needs-attention']
            });

  recover-failed-deployments:
    name: Recover Failed Deployments
    needs: diagnose-issues
    if: needs.diagnose-issues.outputs.failed_resources != ''
    runs-on: ubuntu-latest
    timeout-minutes: 45
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Analyze Recent Failures
        id: analyze
        run: |
          echo "Analyzing recent deployment failures..."
          
          # Get last successful deployment for each environment
          for env in dev staging prod; do
            LAST_SUCCESS=$(gh run list \
              --workflow=terraform-pipeline.yml \
              --status=success \
              --limit=1 \
              --json headSha,createdAt \
              --jq ".[0].headSha" \
              | head -1)
            
            if [ -n "$LAST_SUCCESS" ]; then
              echo "last_success_${env}=${LAST_SUCCESS}" >> $GITHUB_OUTPUT
            fi
          done

      - name: Retry Failed Deployments
        run: |
          for env in dev staging prod; do
            if [ "${{ github.event.inputs.environment }}" != "all" ] && [ "${{ github.event.inputs.environment }}" != "$env" ]; then
              continue
            fi
            
            echo "Attempting to retry deployment for ${env}..."
            
            # Trigger a new deployment with retry logic
            gh workflow run terraform-pipeline.yml \
              -f action=apply \
              -f environment=${env} \
              -f auto_approve=true \
              --ref main
            
            echo "‚úÖ Triggered retry for ${env}"
          done

  heal-unhealthy-resources:
    name: Heal Unhealthy Resources
    needs: diagnose-issues
    if: needs.diagnose-issues.outputs.unhealthy_resources != ''
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup GCP Authentication
        uses: ./.github/actions/setup-gcp
        with:
          auth-method: ${{ secrets.WIF_PROVIDER && 'workload-identity' || 'service-account' }}
          wif-provider: ${{ secrets.WIF_PROVIDER }}
          wif-service-account: ${{ secrets.WIF_SERVICE_ACCOUNT }}
          service-account-key: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
          project-id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Heal Resources
        run: |
          UNHEALTHY="${{ needs.diagnose-issues.outputs.unhealthy_resources }}"
          IFS=',' read -ra RESOURCES <<< "$UNHEALTHY"
          
          for resource in "${RESOURCES[@]}"; do
            echo "Attempting to heal: ${resource}"
            
            if [[ "$resource" == *"-gke" ]]; then
              # Restart GKE cluster master
              ENV=$(echo $resource | cut -d'-' -f1)
              echo "Restarting GKE cluster master for ${ENV}..."
              
              gcloud container clusters update ${ENV}-us-central1-gke \
                --zone=us-central1-a \
                --project=${{ secrets.GCP_PROJECT_ID }} \
                --logging-service=logging.googleapis.com/kubernetes || true
              
            elif [[ "$resource" == *"-sql" ]]; then
              # Restart Cloud SQL instances
              ENV=$(echo $resource | cut -d'-' -f1)
              echo "Restarting Cloud SQL instances for ${ENV}..."
              
              INSTANCES=$(gcloud sql instances list \
                --project=${{ secrets.GCP_PROJECT_ID }} \
                --filter="name:${ENV}-*" \
                --format="value(name)")
              
              for instance in $INSTANCES; do
                echo "Restarting ${instance}..."
                gcloud sql instances restart ${instance} \
                  --project=${{ secrets.GCP_PROJECT_ID }} --async || true
              done
            fi
          done
          
          # Wait and verify
          sleep 60
          echo "Verifying resource health..."
          
          # Re-check health status
          for resource in "${RESOURCES[@]}"; do
            if [[ "$resource" == *"-gke" ]]; then
              ENV=$(echo $resource | cut -d'-' -f1)
              STATUS=$(gcloud container clusters describe ${ENV}-us-central1-gke \
                --zone=us-central1-a \
                --project=${{ secrets.GCP_PROJECT_ID }} \
                --format="value(status)" 2>/dev/null || echo "UNKNOWN")
              
              if [ "$STATUS" = "RUNNING" ]; then
                echo "‚úÖ GKE cluster ${ENV} is healthy"
              else
                echo "‚ö†Ô∏è GKE cluster ${ENV} still unhealthy: ${STATUS}"
              fi
            fi
          done

  healing-summary:
    name: Self-Healing Summary
    needs: [diagnose-issues, fix-state-locks, recover-failed-deployments, heal-unhealthy-resources]
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
      - name: Generate Summary
        run: |
          echo "## üîß Self-Healing Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Run Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Issue Type:** ${{ github.event.inputs.issue_type }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### Issues Detected" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.diagnose-issues.outputs.issues_found }}" = "true" ]; then
            [ -n "${{ needs.diagnose-issues.outputs.state_locks }}" ] && echo "- State Locks: ${{ needs.diagnose-issues.outputs.state_locks }}" >> $GITHUB_STEP_SUMMARY
            [ -n "${{ needs.diagnose-issues.outputs.failed_resources }}" ] && echo "- Failed Deployments: Yes" >> $GITHUB_STEP_SUMMARY
            [ -n "${{ needs.diagnose-issues.outputs.unhealthy_resources }}" ] && echo "- Unhealthy Resources: ${{ needs.diagnose-issues.outputs.unhealthy_resources }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚úÖ No issues detected" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Remediation Actions" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Action | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Fix State Locks | ${{ needs.fix-state-locks.result || 'N/A' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Recover Deployments | ${{ needs.recover-failed-deployments.result || 'N/A' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Heal Resources | ${{ needs.heal-unhealthy-resources.result || 'N/A' }} |" >> $GITHUB_STEP_SUMMARY

      - name: Send Notification
        if: needs.diagnose-issues.outputs.issues_found == 'true'
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: |
            Self-Healing Complete
            Issues Found: ${{ needs.diagnose-issues.outputs.issues_found }}
            State Locks Fixed: ${{ needs.fix-state-locks.result || 'N/A' }}
            Deployments Recovered: ${{ needs.recover-failed-deployments.result || 'N/A' }}
            Resources Healed: ${{ needs.heal-unhealthy-resources.result || 'N/A' }}
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}