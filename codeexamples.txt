# Terragrunt GCP Implementation Plan with Testing

## Phase 0: Prerequisites & Initial Setup (Week 1)

### Step 0.1: GCP Project Setup
**Tasks:**
```bash
# Create GCP projects
gcloud projects create acme-dev-project --organization=$ORG_ID
gcloud projects create acme-staging-project --organization=$ORG_ID
gcloud projects create acme-prod-project --organization=$ORG_ID

# Link billing accounts
gcloud beta billing projects link acme-dev-project --billing-account=$BILLING_ID
gcloud beta billing projects link acme-staging-project --billing-account=$BILLING_ID
gcloud beta billing projects link acme-prod-project --billing-account=$BILLING_ID

# Enable required APIs for each project
for PROJECT in acme-dev-project acme-staging-project acme-prod-project; do
  gcloud config set project $PROJECT
  gcloud services enable compute.googleapis.com
  gcloud services enable container.googleapis.com
  gcloud services enable cloudbuild.googleapis.com
  gcloud services enable secretmanager.googleapis.com
  gcloud services enable cloudresourcemanager.googleapis.com
  gcloud services enable iam.googleapis.com
  gcloud services enable storage.googleapis.com
  gcloud services enable sqladmin.googleapis.com
  gcloud services enable redis.googleapis.com
  gcloud services enable run.googleapis.com
  gcloud services enable cloudfunctions.googleapis.com
  gcloud services enable appengine.googleapis.com
  gcloud services enable pubsub.googleapis.com
  gcloud services enable bigquery.googleapis.com
  gcloud services enable monitoring.googleapis.com
  gcloud services enable logging.googleapis.com
done
```

**Testing:**
```bash
# Verify projects exist
gcloud projects list --filter="project_id:acme-*"

# Verify APIs are enabled
gcloud services list --enabled --project=acme-dev-project

# Expected output: All required APIs should be listed as enabled
```

### Step 0.2: Service Account Setup
**Tasks:**
```bash
# Create Terraform service accounts
for ENV in dev staging prod; do
  PROJECT="acme-${ENV}-project"
  gcloud iam service-accounts create terraform-sa \
    --display-name="Terraform Service Account" \
    --project=$PROJECT
  
  # Grant necessary permissions
  gcloud projects add-iam-policy-binding $PROJECT \
    --member="serviceAccount:terraform-sa@${PROJECT}.iam.gserviceaccount.com" \
    --role="roles/owner"
  
  # Create and download key
  gcloud iam service-accounts keys create ~/keys/${ENV}-terraform-key.json \
    --iam-account=terraform-sa@${PROJECT}.iam.gserviceaccount.com \
    --project=$PROJECT
done

# Set up GitHub Actions service accounts for Workload Identity Federation
for ENV in dev staging prod; do
  PROJECT="acme-${ENV}-project"
  
  # Create service account for GitHub Actions
  gcloud iam service-accounts create github-actions-sa \
    --display-name="GitHub Actions Service Account" \
    --project=$PROJECT
  
  # Create Workload Identity Pool
  gcloud iam workload-identity-pools create github-pool \
    --location="global" \
    --display-name="GitHub Pool" \
    --project=$PROJECT
  
  # Create Workload Identity Provider
  gcloud iam workload-identity-pools providers create-oidc github-provider \
    --location="global" \
    --workload-identity-pool="github-pool" \
    --display-name="GitHub Provider" \
    --attribute-mapping="google.subject=assertion.sub,attribute.repository=assertion.repository" \
    --issuer-uri="https://token.actions.githubusercontent.com" \
    --project=$PROJECT
done
```

**Testing:**
```bash
# Test service account authentication
export GOOGLE_APPLICATION_CREDENTIALS=~/keys/dev-terraform-key.json
gcloud auth application-default print-access-token

# Verify service accounts exist
gcloud iam service-accounts list --project=acme-dev-project

# Test Workload Identity Pool
gcloud iam workload-identity-pools describe github-pool \
  --location=global \
  --project=acme-dev-project
```

### Step 0.3: State Bucket Creation
**Tasks:**
```bash
# Create state buckets with versioning and encryption
for ENV in dev staging prod; do
  PROJECT="acme-${ENV}-project"
  BUCKET="acme-terraform-state-${ENV}"
  
  # Create bucket
  gsutil mb -p $PROJECT -c STANDARD -l us-central1 gs://$BUCKET/
  
  # Enable versioning
  gsutil versioning set on gs://$BUCKET/
  
  # Enable encryption
  gsutil encryption set gs://$BUCKET/
  
  # Set lifecycle policy
  cat > lifecycle.json <<EOF
{
  "lifecycle": {
    "rule": [
      {
        "action": {"type": "Delete"},
        "condition": {
          "age": 90,
          "isLive": false
        }
      }
    ]
  }
}
EOF
  
  gsutil lifecycle set lifecycle.json gs://$BUCKET/
done
```

**Testing:**
```bash
# Verify buckets exist
gsutil ls | grep terraform-state

# Test write access
echo "test" | gsutil cp - gs://acme-terraform-state-dev/test.txt
gsutil rm gs://acme-terraform-state-dev/test.txt

# Verify versioning is enabled
gsutil versioning get gs://acme-terraform-state-dev/
```

## Phase 1: Core Infrastructure Setup (Week 2)

### Step 1.1: Initialize Terragrunt Structure
**Tasks:**
```bash
# Clone repository and set up structure
git clone <your-repo>
cd infrastructure

# Create initial configuration files
cp terragrunt.hcl.example terragrunt.hcl
cp accounts/account.hcl.example accounts/account.hcl

# Update account.hcl with your organization details
sed -i 's/acme-corp/your-org/g' accounts/account.hcl

# Initialize dev environment
cd environments/dev
terragrunt init
```

**Testing:**
```bash
# Validate Terragrunt configuration
terragrunt validate-all

# Dry run to check configuration
terragrunt run-all plan --terragrunt-non-interactive 2>&1 | tee plan.log

# Verify no errors in plan
grep -i error plan.log && echo "Errors found!" || echo "No errors found"
```

### Step 1.2: Deploy VPC Network
**Tasks:**
```bash
cd infrastructure/environments/dev

# Deploy VPC
terragrunt apply --terragrunt-working-dir dev-us-central1-vpc.hcl -auto-approve

# Deploy Subnets
terragrunt apply --terragrunt-working-dir dev-us-central1-subnets.hcl -auto-approve

# Deploy NAT Gateway
terragrunt apply --terragrunt-working-dir dev-us-central1-nat.hcl -auto-approve

# Deploy Firewall Rules
terragrunt apply --terragrunt-working-dir dev-us-central1-firewall.hcl -auto-approve
```

**Testing:**
```bash
# Verify VPC creation
gcloud compute networks describe dev-us-central1-vpc --project=acme-dev-project

# Test subnet creation
gcloud compute networks subnets list --project=acme-dev-project

# Verify NAT gateway
gcloud compute routers nats describe dev-us-central1-nat \
  --router=dev-us-central1-router \
  --region=us-central1 \
  --project=acme-dev-project

# Test firewall rules
gcloud compute firewall-rules list --project=acme-dev-project

# Connectivity test
cat > test-vm.sh <<'EOF'
#!/bin/bash
# Create a test VM
gcloud compute instances create test-vm \
  --zone=us-central1-a \
  --subnet=dev-us-central1-private \
  --no-address \
  --project=acme-dev-project

# SSH through IAP and test internet connectivity
gcloud compute ssh test-vm \
  --zone=us-central1-a \
  --tunnel-through-iap \
  --project=acme-dev-project \
  --command="curl -I https://www.google.com"

# Clean up
gcloud compute instances delete test-vm \
  --zone=us-central1-a \
  --quiet \
  --project=acme-dev-project
EOF

chmod +x test-vm.sh
./test-vm.sh
```

### Step 1.3: Deploy IAM and Security Foundation
**Tasks:**
```bash
# Deploy KMS
terragrunt apply --terragrunt-working-dir dev-us-central1-kms.hcl -auto-approve

# Deploy IAM roles and bindings
terragrunt apply --terragrunt-working-dir dev-us-central1-iam.hcl -auto-approve

# Deploy Secret Manager (without secrets yet)
terragrunt apply --terragrunt-working-dir dev-us-central1-secrets.hcl -auto-approve
```

**Testing:**
```bash
# Verify KMS key ring and keys
gcloud kms keyrings list --location=us-central1 --project=acme-dev-project
gcloud kms keys list --keyring=app-keyring --location=us-central1 --project=acme-dev-project

# Test IAM roles
gcloud projects get-iam-policy acme-dev-project

# Verify Secret Manager
gcloud secrets list --project=acme-dev-project

# Test encryption/decryption with KMS
echo "test data" | gcloud kms encrypt \
  --key=secret-key \
  --keyring=app-keyring \
  --location=us-central1 \
  --plaintext-file=- \
  --ciphertext-file=- | base64

# Create and access a test secret
echo -n "test-secret-value" | gcloud secrets create test-secret \
  --data-file=- \
  --project=acme-dev-project

gcloud secrets versions access latest --secret=test-secret --project=acme-dev-project
```

## Phase 2: Data Layer (Week 3)

### Step 2.1: Deploy Storage Solutions
**Tasks:**
```bash
# Deploy GCS buckets
terragrunt apply --terragrunt-working-dir dev-us-central1-gcs.hcl -auto-approve

# Deploy BigQuery datasets and tables
terragrunt apply --terragrunt-working-dir dev-us-central1-bigquery.hcl -auto-approve

# Deploy Pub/Sub topics and subscriptions
terragrunt apply --terragrunt-working-dir dev-us-central1-pubsub.hcl -auto-approve
```

**Testing:**
```bash
# Test GCS bucket access
echo "test file" > test.txt
gsutil cp test.txt gs://acme-dev-static/
gsutil cat gs://acme-dev-static/test.txt
gsutil rm gs://acme-dev-static/test.txt
rm test.txt

# Test BigQuery
bq query --project_id=acme-dev-project --use_legacy_sql=false \
  "SELECT 'Hello World' as greeting"

# Insert test data into BigQuery
cat > test_events.json <<EOF
{"event_id":"1","timestamp":"2024-01-01T00:00:00Z","user_id":"user1","event_type":"click","properties":"{\"page\":\"home\"}"}
{"event_id":"2","timestamp":"2024-01-01T00:01:00Z","user_id":"user2","event_type":"view","properties":"{\"page\":\"about\"}"}
EOF

bq load --source_format=NEWLINE_DELIMITED_JSON \
  --project_id=acme-dev-project \
  dev_us_central1_analytics.events \
  test_events.json

# Query the data
bq query --project_id=acme-dev-project --use_legacy_sql=false \
  "SELECT * FROM dev_us_central1_analytics.events LIMIT 10"

# Test Pub/Sub
gcloud pubsub topics publish dev-us-central1-events \
  --message="Test message" \
  --project=acme-dev-project

gcloud pubsub subscriptions pull dev-us-central1-events-processor \
  --auto-ack \
  --project=acme-dev-project
```

### Step 2.2: Deploy Databases
**Tasks:**
```bash
# Deploy Cloud SQL
terragrunt apply --terragrunt-working-dir dev-us-central1-cloud-sql.hcl -auto-approve

# Deploy Redis
terragrunt apply --terragrunt-working-dir dev-us-central1-redis.hcl -auto-approve
```

**Testing:**
```bash
# Test Cloud SQL connectivity
# Get the connection name
INSTANCE_CONNECTION=$(gcloud sql instances describe dev-us-central1-db \
  --project=acme-dev-project \
  --format="value(connectionName)")

# Create a test database
gcloud sql databases create testdb \
  --instance=dev-us-central1-db \
  --project=acme-dev-project

# Test connection via proxy
cloud_sql_proxy -instances=$INSTANCE_CONNECTION=tcp:5432 &
PROXY_PID=$!

sleep 5

# Test connection (requires psql installed)
PGPASSWORD=$(gcloud secrets versions access latest \
  --secret=dev-us-central1-db-password \
  --project=acme-dev-project) \
psql -h localhost -U postgres -d testdb -c "SELECT version();"

kill $PROXY_PID

# Test Redis connectivity
gcloud redis instances describe dev-us-central1-redis \
  --region=us-central1 \
  --project=acme-dev-project

# Get Redis host
REDIS_HOST=$(gcloud redis instances describe dev-us-central1-redis \
  --region=us-central1 \
  --project=acme-dev-project \
  --format="value(host)")

# Test from a VM in the same VPC
cat > test-redis.sh <<EOF
#!/bin/bash
gcloud compute instances create redis-test \
  --zone=us-central1-a \
  --subnet=dev-us-central1-private \
  --project=acme-dev-project

gcloud compute ssh redis-test \
  --zone=us-central1-a \
  --project=acme-dev-project \
  --command="sudo apt-get update && sudo apt-get install -y redis-tools && redis-cli -h $REDIS_HOST ping"

gcloud compute instances delete redis-test \
  --zone=us-central1-a \
  --quiet \
  --project=acme-dev-project
EOF

chmod +x test-redis.sh
./test-redis.sh
```

## Phase 3: Compute Layer (Week 4)

### Step 3.1: Deploy GKE Cluster
**Tasks:**
```bash
# Deploy GKE cluster
terragrunt apply --terragrunt-working-dir dev-us-central1-gke.hcl -auto-approve
```

**Testing:**
```bash
# Get cluster credentials
gcloud container clusters get-credentials dev-us-central1-gke \
  --region=us-central1 \
  --project=acme-dev-project

# Verify cluster is running
kubectl get nodes

# Deploy a test application
cat > test-deployment.yaml <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-test
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  selector:
    app: nginx
  ports:
  - port: 80
    targetPort: 80
  type: LoadBalancer
EOF

kubectl apply -f test-deployment.yaml

# Wait for external IP
kubectl get service nginx-service --watch

# Test the deployment
EXTERNAL_IP=$(kubectl get service nginx-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
curl http://$EXTERNAL_IP

# Cleanup
kubectl delete -f test-deployment.yaml
```

### Step 3.2: Deploy Cloud Run Services
**Tasks:**
```bash
# Build and push sample containers first
cat > Dockerfile <<EOF
FROM gcr.io/distroless/nodejs18-debian11
COPY app.js .
EXPOSE 8080
CMD ["app.js"]
EOF

cat > app.js <<EOF
const http = require('http');
const server = http.createServer((req, res) => {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('Hello from Cloud Run!');
});
server.listen(8080);
EOF

# Build and push
gcloud builds submit --tag gcr.io/acme-dev-project/api-service:latest
gcloud builds submit --tag gcr.io/acme-dev-project/web-service:latest

# Deploy Cloud Run
terragrunt apply --terragrunt-working-dir dev-us-central1-cloud-run.hcl -auto-approve
```

**Testing:**
```bash
# Get Cloud Run service URL
API_URL=$(gcloud run services describe dev-us-central1-api \
  --region=us-central1 \
  --project=acme-dev-project \
  --format="value(status.url)")

WEB_URL=$(gcloud run services describe dev-us-central1-web \
  --region=us-central1 \
  --project=acme-dev-project \
  --format="value(status.url)")

# Test the services
curl -H "Authorization: Bearer $(gcloud auth print-identity-token)" $API_URL
curl -H "Authorization: Bearer $(gcloud auth print-identity-token)" $WEB_URL

# Test auto-scaling
hey -z 30s -c 50 -H "Authorization: Bearer $(gcloud auth print-identity-token)" $API_URL

# Monitor instances
gcloud run services describe dev-us-central1-api \
  --region=us-central1 \
  --project=acme-dev-project \
  --format="value(status.conditions[0].message)"
```

### Step 3.3: Deploy Cloud Functions
**Tasks:**
```bash
# Prepare function source code
mkdir -p functions/process-upload
cat > functions/process-upload/main.py <<EOF
def process_upload(event, context):
    print(f"Processing file: {event['name']}")
    return "Success"
EOF

cat > functions/process-upload/requirements.txt <<EOF
google-cloud-storage==2.10.0
EOF

# Zip and upload to GCS
cd functions/process-upload
zip -r process-upload.zip .
gsutil cp process-upload.zip gs://acme-function-source/
cd ../..

# Deploy Cloud Functions
terragrunt apply --terragrunt-working-dir dev-us-central1-cloud-functions.hcl -auto-approve
```

**Testing:**
```bash
# Test HTTP-triggered function
WEBHOOK_URL=$(gcloud functions describe dev-us-central1-webhook \
  --region=us-central1 \
  --project=acme-dev-project \
  --format="value(httpsTrigger.url)")

curl -X POST $WEBHOOK_URL \
  -H "Content-Type: application/json" \
  -d '{"test": "data"}'

# Test event-triggered function
echo "test file content" > test.txt
gsutil cp test.txt gs://acme-uploads-dev/
sleep 5

# Check function logs
gcloud functions logs read dev-us-central1-process-upload \
  --region=us-central1 \
  --project=acme-dev-project \
  --limit=10

# Test Pub/Sub triggered function (Gen2)
gcloud pubsub topics publish dev-us-central1-events \
  --message='{"event": "test"}' \
  --project=acme-dev-project

# Check Gen2 function logs
gcloud functions logs read dev-us-central1-event-processor \
  --region=us-central1 \
  --project=acme-dev-project \
  --limit=10
```

### Step 3.4: Deploy App Engine
**Tasks:**
```bash
# Prepare App Engine applications
mkdir -p app-engine/default
cat > app-engine/default/main.py <<EOF
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello():
    return 'Hello from App Engine!'

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)
EOF

cat > app-engine/default/requirements.txt <<EOF
Flask==2.3.0
gunicorn==20.1.0
EOF

cat > app-engine/default/app.yaml <<EOF
runtime: python39
entrypoint: gunicorn -b :8080 main:app
EOF

# Upload to GCS
gsutil cp -r app-engine/* gs://acme-deployments/app-engine/

# Deploy App Engine
terragrunt apply --terragrunt-working-dir dev-us-central1-app-engine.hcl -auto-approve
```

**Testing:**
```bash
# Deploy test version
cd app-engine/default
gcloud app deploy --project=acme-dev-project --quiet

# Test App Engine
APP_URL="https://acme-dev-project.appspot.com"
curl $APP_URL

# Test traffic splitting
gcloud app services set-traffic default --splits v1=1.0 --project=acme-dev-project

# Check App Engine metrics
gcloud app instances list --project=acme-dev-project
```

## Phase 4: Networking & Load Balancing (Week 5)

### Step 4.1: Deploy Load Balancer
**Tasks:**
```bash
# Deploy Load Balancer
terragrunt apply --terragrunt-working-dir dev-us-central1-load-balancer.hcl -auto-approve
```

**Testing:**
```bash
# Get load balancer IP
LB_IP=$(gcloud compute addresses describe dev-us-central1-lb-ip \
  --global \
  --project=acme-dev-project \
  --format="value(address)")

echo "Load Balancer IP: $LB_IP"

# Test HTTP redirect
curl -I http://$LB_IP

# For HTTPS testing, you'll need to configure DNS first
# Add A record pointing to $LB_IP for dev.acme.com

# After DNS propagation (use a test domain or hosts file)
echo "$LB_IP dev.acme.com" | sudo tee -a /etc/hosts
echo "$LB_IP api-dev.acme.com" | sudo tee -a /etc/hosts

# Test HTTPS (certificate provisioning may take up to 20 minutes)
curl -I https://dev.acme.com
curl -I https://api-dev.acme.com

# Test backend health
gcloud compute backend-services get-health dev-us-central1-lb-gke-web \
  --global \
  --project=acme-dev-project

# Load test
hey -z 60s -c 100 https://dev.acme.com
```

### Step 4.2: Deploy CDN
**Tasks:**
```bash
# Deploy CDN configuration
terragrunt apply --terragrunt-working-dir dev-us-central1-cdn.hcl -auto-approve
```

**Testing:**
```bash
# Upload test content to CDN buckets
echo "<html><body>CDN Test</body></html>" > index.html
gsutil cp index.html gs://acme-static-dev/
gsutil cp index.html gs://acme-media-dev/

# Test CDN caching
BUCKET_URL="https://storage.googleapis.com/acme-static-dev/index.html"

# First request (cache miss)
curl -I $BUCKET_URL | grep -i cache

# Second request (cache hit)
curl -I $BUCKET_URL | grep -i cache

# Test cache invalidation
gcloud compute url-maps invalidate-cdn-cache dev-us-central1-lb \
  --path="/index.html" \
  --project=acme-dev-project

# Performance test
hey -z 30s -c 50 $BUCKET_URL
```

## Phase 5: Monitoring & Observability (Week 6)

### Step 5.1: Deploy Logging & Monitoring
**Tasks:**
```bash
# Deploy Logging configuration
terragrunt apply --terragrunt-working-dir dev-us-central1-logging.hcl -auto-approve

# Deploy Monitoring
terragrunt apply --terragrunt-working-dir dev-us-central1-monitoring.hcl -auto-approve

# Deploy Alerts
terragrunt apply --terragrunt-working-dir dev-us-central1-alerts.hcl -auto-approve
```

**Testing:**
```bash
# Test log aggregation
gcloud logging read "resource.type=gce_instance" \
  --project=acme-dev-project \
  --limit=10

# Test custom metrics
cat > test-metric.sh <<EOF
#!/bin/bash
# Send custom metric
gcloud monitoring time-series create \
  --project=acme-dev-project \
  --metric-type="custom.googleapis.com/test/metric" \
  --resource-type="global" \
  --points="value=42,end-time=$(date +%s)" \
  --points-value-type="INT64"
EOF

chmod +x test-metric.sh
./test-metric.sh

# Query the metric
gcloud monitoring time-series list \
  --filter='metric.type="custom.googleapis.com/test/metric"' \
  --project=acme-dev-project

# Test alert policy
# Trigger a test alert by creating high CPU usage
gcloud compute instances create alert-test \
  --zone=us-central1-a \
  --project=acme-dev-project

gcloud compute ssh alert-test \
  --zone=us-central1-a \
  --project=acme-dev-project \
  --command="stress --cpu 8 --timeout 60s"

# Check alert status
gcloud alpha monitoring policies list --project=acme-dev-project

# Cleanup
gcloud compute instances delete alert-test \
  --zone=us-central1-a \
  --quiet \
  --project=acme-dev-project
```

## Phase 6: CI/CD Pipeline Setup (Week 7)

### Step 6.1: Configure GitHub Repository
**Tasks:**
```bash
# Set up GitHub secrets
gh secret set GCP_SA_dev --body "$(cat ~/keys/dev-terraform-key.json)"
gh secret set GCP_SA_staging --body "$(cat ~/keys/staging-terraform-key.json)"
gh secret set GCP_SA_prod --body "$(cat ~/keys/prod-terraform-key.json)"
gh secret set INFRACOST_API_KEY --body "your-infracost-api-key"
gh secret set SLACK_WEBHOOK --body "your-slack-webhook-url"

# Set up Workload Identity Federation
WIF_PROVIDER=$(gcloud iam workload-identity-pools providers describe github-provider \
  --workload-identity-pool=github-pool \
  --location=global \
  --project=acme-dev-project \
  --format="value(name)")

gh secret set WIF_PROVIDER --body "$WIF_PROVIDER"

# Configure branch protection
gh api repos/:owner/:repo/branches/main/protection \
  --method PUT \
  --field required_status_checks='{"strict":true,"contexts":["validate","security-scan","plan"]}' \
  --field enforce_admins=false \
  --field required_pull_request_reviews='{"required_approving_review_count":1}'
```

**Testing:**
```bash
# Create a test PR
git checkout -b test/ci-pipeline
echo "# Test change" >> README.md
git add README.md
git commit -m "Test CI pipeline"
git push origin test/ci-pipeline

# Create PR
gh pr create --title "Test CI Pipeline" --body "Testing the CI/CD setup"

# Monitor workflow
gh run watch

# Check PR comments for plan output
gh pr view --comments
```

### Step 6.2: Test Full Deployment Pipeline
**Tasks:**
```bash
# Test manual deployment
gh workflow run terraform-ci-cd.yml \
  -f action=plan \
  -f environment=dev \
  -f resource=""

# Monitor the run
gh run list --workflow=terraform-ci-cd.yml
gh run watch

# Test apply
gh workflow run terraform-ci-cd.yml \
  -f action=apply \
  -f environment=dev \
  -f resource=""
```

**Testing:**
```bash
# Verify deployment succeeded
terragrunt run-all output --terragrunt-non-interactive \
  --terragrunt-working-dir infrastructure/environments/dev

# Test destroy for a single resource (non-critical)
gh workflow run terraform-ci-cd.yml \
  -f action=destroy \
  -f environment=dev \
  -f resource="dev-us-central1-alerts"
```

## Phase 7: Multi-Environment Rollout (Week 8)

### Step 7.1: Deploy Staging Environment
**Tasks:**
```bash
# Copy dev configurations to staging
cd infrastructure/environments
cp -r dev staging
cd staging

# Update environment-specific values
find . -name "*.hcl" -exec sed -i 's/dev/staging/g' {} \;

# Deploy staging infrastructure
terragrunt run-all apply --terragrunt-non-interactive
```

**Testing:**
```bash
# Run the same test suite as dev
./run-tests.sh staging

# Performance comparison
hey -z 60s -c 100 https://staging.acme.com > staging-perf.txt
hey -z 60s -c 100 https://dev.acme.com > dev-perf.txt
diff staging-perf.txt dev-perf.txt
```

### Step 7.2: Production Deployment
**Tasks:**
```bash
# Prepare production with enhanced settings
cd infrastructure/environments
cp -r staging prod
cd prod

# Update for production settings
# - No preemptible instances
# - Higher resource allocations
# - Multi-zone redundancy
# - Enhanced monitoring

# Deploy production infrastructure
terragrunt run-all apply --terragrunt-non-interactive --terragrunt-parallelism 1
```

**Testing:**
```bash
# Smoke tests only for production
curl -I https://acme.com
curl -I https://api.acme.com

# Health checks
gcloud compute health-checks list --project=acme-prod-project

# Monitoring dashboard
gcloud monitoring dashboards list --project=acme-prod-project
```

## Phase 8: Validation & Documentation (Week 9)

### Step 8.1: End-to-End Testing
**Tasks:**
```bash
# Create comprehensive test suite
cat > e2e-test.sh <<'EOF'
#!/bin/bash
set -e

ENV=$1
PROJECT="acme-${ENV}-project"

echo "Testing environment: $ENV"

# Test networking
echo "Testing VPC..."
gcloud compute networks describe ${ENV}-us-central1-vpc --project=$PROJECT

# Test compute
echo "Testing GKE..."
kubectl get nodes --kubeconfig=~/.kube/config-$ENV

# Test data layer
echo "Testing BigQuery..."
bq query --project_id=$PROJECT --use_legacy_sql=false "SELECT 1"

# Test storage
echo "Testing GCS..."
gsutil ls gs://acme-static-$ENV/

# Test applications
echo "Testing Cloud Run..."
gcloud run services list --region=us-central1 --project=$PROJECT

# Test security
echo "Testing secrets..."
gcloud secrets list --project=$PROJECT

echo "All tests passed for $ENV!"
EOF

chmod +x e2e-test.sh

# Run for all environments
for ENV in dev staging prod; do
  ./e2e-test.sh $ENV
done
```

### Step 8.2: Cost Analysis
**Tasks:**
```bash
# Generate cost reports
for ENV in dev staging prod; do
  cd infrastructure/environments/$ENV
  infracost breakdown --path . \
    --format html \
    --out-file ~/cost-report-$ENV.html
done

# Compare environments
infracost diff \
  --path infrastructure/environments/dev \
  --compare-to infrastructure/environments/prod \
  --format table
```

### Step 8.3: Documentation
**Tasks:**
```bash
# Generate resource documentation
cd infrastructure
terraform-docs markdown table --recursive . > RESOURCES.md

# Create runbooks
cat > RUNBOOKS.md <<EOF
# Operational Runbooks

## Disaster Recovery
1. Database backup restoration
2. GKE cluster recovery
3. Secret rotation procedures

## Scaling Procedures
1. GKE node pool scaling
2. Cloud Run instance scaling
3. Database read replica addition

## Monitoring
1. Alert response procedures
2. Log analysis queries
3. Performance optimization steps
EOF
```

## Testing Checklist Summary

### ✅ Infrastructure Tests
- [ ] VPC and subnet connectivity
- [ ] NAT gateway functionality
- [ ] Firewall rules effectiveness
- [ ] DNS resolution
- [ ] Load balancer health checks
- [ ] CDN cache hit rates

### ✅ Security Tests
- [ ] IAM permissions verification
- [ ] Secret Manager access
- [ ] KMS encryption/decryption
- [ ] Service account permissions
- [ ] Network security policies

### ✅ Application Tests
- [ ] GKE cluster deployment
- [ ] Cloud Run auto-scaling
- [ ] Cloud Functions triggers
- [ ] App Engine traffic splitting
- [ ] API endpoint responses

### ✅ Data Tests
- [ ] BigQuery query execution
- [ ] Pub/Sub message delivery
- [ ] Cloud SQL connectivity
- [ ] Redis cache operations
- [ ] GCS bucket access

### ✅ Operational Tests
- [ ] Log aggregation
- [ ] Metric collection
- [ ] Alert triggering
- [ ] Backup procedures
- [ ] CI/CD pipeline execution

## Rollback Procedures

For each phase, maintain rollback capability:

```bash
# Rollback to previous state
cd infrastructure/environments/$ENV
terragrunt run-all destroy --terragrunt-non-interactive

# Or rollback specific resource
terragrunt destroy --terragrunt-working-dir $RESOURCE.hcl

# Restore from state backup
gsutil cp gs://acme-terraform-state-$ENV/backup/terraform.tfstate .
terragrunt import ...
```

## Success Metrics

Track these KPIs throughout implementation:

1. **Deployment Success Rate**: >95%
2. **Infrastructure Cost**: Within 10% of estimate
3. **Performance Benchmarks**:
   - API response time: <200ms p95
   - Page load time: <2s
   - Database query time: <100ms p95
4. **Security Score**: 90+ on Security Command Center
5. **Uptime**: 99.9% for production

## Timeline Summary

- **Week 1**: Prerequisites & Setup
- **Week 2**: Core Infrastructure
- **Week 3**: Data Layer
- **Week 4**: Compute Layer
- **Week 5**: Networking & Load Balancing
- **Week 6**: Monitoring & Observability
- **Week 7**: CI/CD Pipeline
- **Week 8**: Multi-Environment Rollout
- **Week 9**: Validation & Documentation

Total Duration: 9 weeks for complete implementation with comprehensive testing