# Advanced GCP Configurations and CI/CD

## Cloud Functions Implementation
```hcl
# infrastructure/environments/dev/dev-us-central1-cloud-functions.hcl

terraform {
  source = "../../modules/compute/cloud-functions"
}

include "root" {
  path = find_in_parent_folders()
}

dependency "vpc" {
  config_path = "."
  mock_outputs = {
    vpc_connector_id = "mock-connector"
  }
}

dependency "pubsub" {
  config_path = "."
  mock_outputs = {
    topic_ids = {
      "events" = "mock-events-topic"
      "notifications" = "mock-notifications-topic"
    }
  }
}

dependency "secrets" {
  config_path = "."
  mock_outputs = {
    secret_ids = {
      "api-key" = "projects/mock/secrets/api-key"
    }
  }
}

locals {
  env_vars = read_terragrunt_config(find_in_parent_folders("env.hcl"))
  common_vars = read_terragrunt_config(find_in_parent_folders("terragrunt.hcl"))
}

inputs = {
  gen1_functions = {
    "process-upload" = {
      name        = "${local.env_vars.locals.environment}-${local.env_vars.locals.region}-process-upload"
      description = "Process file uploads from GCS"
      runtime     = "python39"
      region      = local.env_vars.locals.region
      
      memory_mb   = 256
      timeout     = 60
      entry_point = "process_upload"
      
      source_bucket = "${local.common_vars.locals.organization}-function-source"
      source_object = "process-upload.zip"
      
      event_trigger = {
        event_type = "google.storage.object.finalize"
        resource   = "${local.common_vars.locals.organization}-uploads-${local.env_vars.locals.environment}"
        
        failure_policy = {
          retry = true
        }
      }
      
      vpc_connector = dependency.vpc.outputs.vpc_connector_id
      vpc_connector_egress_settings = "PRIVATE_RANGES_ONLY"
      
      service_account_email = "${local.env_vars.locals.environment}-functions-sa@${local.common_vars.locals.project_id}.iam.gserviceaccount.com"
      
      environment_variables = {
        ENVIRONMENT = local.env_vars.locals.environment
        PROJECT_ID  = local.common_vars.locals.project_id
        LOG_LEVEL   = local.env_vars.locals.environment == "prod" ? "INFO" : "DEBUG"
      }
      
      max_instances = local.env_vars.locals.environment == "prod" ? 100 : 10
      min_instances = 0
    }
    
    "webhook-handler" = {
      name        = "${local.env_vars.locals.environment}-${local.env_vars.locals.region}-webhook"
      description = "Handle external webhooks"
      runtime     = "nodejs16"
      region      = local.env_vars.locals.region
      
      memory_mb    = 512
      timeout      = 30
      entry_point  = "handleWebhook"
      trigger_http = true
      
      source_bucket = "${local.common_vars.locals.organization}-function-source"
      source_object = "webhook-handler.zip"
      
      ingress_settings = "ALLOW_ALL"
      
      environment_variables = {
        NODE_ENV    = local.env_vars.locals.environment == "prod" ? "production" : "development"
        API_ENDPOINT = "https://api-${local.env_vars.locals.environment}.${local.common_vars.locals.organization}.com"
      }
      
      max_instances = 50
      min_instances = local.env_vars.locals.environment == "prod" ? 1 : 0
    }
  }
  
  gen2_functions = {
    "event-processor" = {
      name        = "${local.env_vars.locals.environment}-${local.env_vars.locals.region}-event-processor"
      description = "Process events from Pub/Sub"
      runtime     = "python311"
      location    = local.env_vars.locals.region
      
      memory_mb   = 1024
      timeout     = 120
      entry_point = "process_event"
      
      source_bucket = "${local.common_vars.locals.organization}-function-source"
      source_object = "event-processor.zip"
      
      event_trigger = {
        event_type   = "google.cloud.pubsub.topic.v1.messagePublished"
        pubsub_topic = dependency.pubsub.outputs.topic_ids.events
        
        retry_policy = "RETRY_POLICY_RETRY"
        
        service_account_email = "${local.env_vars.locals.environment}-events-sa@${local.common_vars.locals.project_id}.iam.gserviceaccount.com"
      }
      
      vpc_connector = dependency.vpc.outputs.vpc_connector_id
      
      environment_variables = {
        ENVIRONMENT = local.env_vars.locals.environment
        BATCH_SIZE  = "100"
      }
      
      secret_environment_variables = [
        {
          key        = "API_KEY"
          project_id = local.common_vars.locals.project_id
          secret     = "api-key"
          version    = "latest"
        }
      ]
      
      max_instances = 20
      min_instances = 1
      
      iam_bindings = {
        "roles/cloudfunctions.invoker" = [
          "serviceAccount:${local.env_vars.locals.environment}-scheduler-sa@${local.common_vars.locals.project_id}.iam.gserviceaccount.com"
        ]
      }
    }
    
    "notification-sender" = {
      name        = "${local.env_vars.locals.environment}-${local.env_vars.locals.region}-notifications"
      description = "Send notifications via multiple channels"
      runtime     = "go119"
      location    = local.env_vars.locals.region
      
      memory_mb   = 256
      timeout     = 30
      entry_point = "SendNotification"
      
      source_bucket = "${local.common_vars.locals.organization}-function-source"
      source_object = "notification-sender.zip"
      
      event_trigger = {
        event_type   = "google.cloud.pubsub.topic.v1.messagePublished"
        pubsub_topic = dependency.pubsub.outputs.topic_ids.notifications
        
        event_filters = [
          {
            attribute = "type"
            value     = "notification"
          }
        ]
      }
      
      environment_variables = {
        SMTP_HOST = "smtp.gmail.com"
        SMTP_PORT = "587"
      }
      
      secret_environment_variables = [
        {
          key        = "SMTP_PASSWORD"
          project_id = local.common_vars.locals.project_id
          secret     = "smtp-password"
          version    = "latest"
        }
      ]
      
      max_instances = 10
      min_instances = 0
    }
  }
  
  labels = merge(
    local.common_vars.locals.common_labels,
    {
      component = "compute"
      resource  = "cloud-functions"
    }
  )
}
```

## Pub/Sub Implementation
```hcl
# infrastructure/environments/dev/dev-us-central1-pubsub.hcl

terraform {
  source = "../../modules/data/pubsub"
}

include "root" {
  path = find_in_parent_folders()
}

dependency "bigquery" {
  config_path = "."
  mock_outputs = {
    table_ids = {
      "events" = "project.dataset.events"
    }
  }
}

locals {
  env_vars = read_terragrunt_config(find_in_parent_folders("env.hcl"))
  common_vars = read_terragrunt_config(find_in_parent_folders("terragrunt.hcl"))
}

inputs = {
  schemas = {
    "event-schema" = {
      name = "${local.env_vars.locals.environment}-${local.env_vars.locals.region}-event-schema"
      type = "AVRO"
      definition = jsonencode({
        type = "record"
        name = "Event"
        fields = [
          {
            name = "id"
            type = "string"
          },
          {
            name = "timestamp"
            type = "long"
          },
          {
            name = "type"
            type = "string"
          },
          {
            name = "payload"
            type = ["null", "string"]
            default = null
          }
        ]
      })
    }
    
    "notification-schema" = {
      name = "${local.env_vars.locals.environment}-${local.env_vars.locals.region}-notification-schema"
      type = "PROTOCOL_BUFFER"
      definition = file("${get_terragrunt_dir()}/schemas/notification.proto")
    }
  }
  
  topics = {
    "events" = {
      name = "${local.env_vars.locals.environment}-${local.env_vars.locals.region}-events"
      
      schema = {
        schema_key = "event-schema"
        encoding   = "JSON"
      }
      
      message_retention_duration = "604800s" # 7 days
      
      allowed_persistence_regions = [local.env_vars.locals.region]
      
      iam_bindings = {
        "roles/pubsub.publisher" = [
          "serviceAccount:${local.env_vars.locals.environment}-api-sa@${local.common_vars.locals.project_id}.iam.gserviceaccount.com"
        ]
      }
    }
    
    "notifications" = {
      name = "${local.env_vars.locals.environment}-${local.env_vars.locals.region}-notifications"
      
      message_retention_duration = "86400s" # 1 day
    }
    
    "dead-letter" = {
      name = "${local.env_vars.locals.environment}-${local.env_vars.locals.region}-dead-letter"
      
      message_retention_duration = "2592000s" # 30 days
    }
  }
  
  subscriptions = {
    "events-to-bigquery" = {
      name      = "${local.env_vars.locals.environment}-${local.env_vars.locals.region}-events-bq"
      topic_key = "events"
      
      message_retention_duration = "604800s" # 7 days
      retain_acked_messages     = false
      ack_deadline_seconds       = 60
      enable_message_ordering    = false
      enable_exactly_once_delivery = local.env_vars.locals.environment == "prod"
      
      expiration_policy = {
        ttl = "2592000s" # 30 days
      }
      
      retry_policy = {
        minimum_backoff = "10s"
        maximum_backoff = "600s"
      }
      
      dead_letter_policy = {
        topic_key             = "dead-letter"
        max_delivery_attempts = 5
      }
      
      bigquery_config = {
        table               = dependency.bigquery.outputs.table_ids.events
        use_topic_schema    = true
        write_metadata      = true
        drop_unknown_fields = false
      }
      
      iam_bindings = {
        "roles/pubsub.subscriber" = [
          "serviceAccount:${local.env_vars.locals.environment}-bq-sa@${local.common_vars.locals.project_id}.iam.gserviceaccount.com"
        ]
      }
    }
    
    "events-processor" = {
      name      = "${local.env_vars.locals.environment}-${local.env_vars.locals.region}-events-processor"
      topic_key = "events"
      
      message_retention_duration = "86400s" # 1 day
      retain_acked_messages     = false
      ack_deadline_seconds       = 120
      
      push_config = {
        push_endpoint = "https://api-${local.env_vars.locals.environment}.${local.common_vars.locals.organization}.com/webhook/events"
        
        oidc_token = {
          service_account_email = "${local.env_vars.locals.environment}-push-sa@${local.common_vars.locals.project_id}.iam.gserviceaccount.com"
        }
        
        attributes = {
          x-goog-version = "v1"
        }
      }
    }
    
    "notifications-email" = {
      name      = "${local.env_vars.locals.environment}-${local.env_vars.locals.region}-notifications-email"
      topic_key = "notifications"
      
      message_retention_duration = "86400s"
      retain_acked_messages     = false
      ack_deadline_seconds       = 30
      
      filter = "attributes.channel=\"email\""
    }
    
    "notifications-slack" = {
      name      = "${local.env_vars.locals.environment}-${local.env_vars.locals.region}-notifications-slack"
      topic_key = "notifications"
      
      message_retention_duration = "86400s"
      retain_acked_messages     = false
      ack_deadline_seconds       = 30
      
      filter = "attributes.channel=\"slack\""
      
      push_config = {
        push_endpoint = "https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK"
      }
    }
  }
  
  labels = merge(
    local.common_vars.locals.common_labels,
    {
      component = "data"
      resource  = "pubsub"
    }
  )
}
```

## CDN Configuration
```hcl
# infrastructure/environments/dev/dev-us-central1-cdn.hcl

terraform {
  source = "../../modules/networking/cdn"
}

include "root" {
  path = find_in_parent_folders()
}

dependency "gcs" {
  config_path = "."
  mock_outputs = {
    bucket_names = {
      "static" = "mock-static-bucket"
      "media" = "mock-media-bucket"
    }
  }
}

dependency "load_balancer" {
  config_path = "."
  mock_outputs = {
    backend_service_ids = {
      "gke-web" = "mock-backend-service"
    }
  }
}

locals {
  env_vars = read_terragrunt_config(find_in_parent_folders("env.hcl"))
  common_vars = read_terragrunt_config(find_in_parent_folders("terragrunt.hcl"))
}

inputs = {
  name = "${local.env_vars.locals.environment}-${local.env_vars.locals.region}-cdn"
  
  # Cloud CDN for backend services
  backend_cdn_configs = {
    "gke-web" = {
      backend_service_id = dependency.load_balancer.outputs.backend_service_ids["gke-web"]
      
      cache_mode = "CACHE_ALL_STATIC"
      default_ttl = 3600
      max_ttl = 86400
      client_ttl = 3600
      
      negative_caching = true
      negative_caching_policy = [
        {
          code = 404
          ttl = 300
        },
        {
          code = 410
          ttl = 86400
        }
      ]
      
      serve_while_stale = 86400
      
      cache_key_policy = {
        include_host = true
        include_protocol = true
        include_query_string = false
        query_string_whitelist = ["v", "version"]
      }
      
      bypass_cache_on_request_headers = ["X-No-Cache"]
      
      signed_url_keys = [
        {
          key_name = "key1"
          key_value = random_password.cdn_key.result
        }
      ]
    }
  }
  
  # Cloud CDN for storage buckets
  bucket_cdn_configs = {
    "static" = {
      bucket_name = dependency.gcs.outputs.bucket_names.static
      
      enable_cdn = true
      cdn_policy = {
        cache_mode = "USE_ORIGIN_HEADERS"
        default_ttl = 7200
        max_ttl = 31536000 # 1 year for static assets
        client_ttl = 7200
        
        cache_key_policy = {
          include_query_string = true
          query_string_whitelist = ["v", "hash"]
        }
      }
      
      compression_mode = "AUTOMATIC"
    }
    
    "media" = {
      bucket_name = dependency.gcs.outputs.bucket_names.media
      
      enable_cdn = true
      cdn_policy = {
        cache_mode = "FORCE_CACHE_ALL"
        default_ttl = 86400
        max_ttl = 604800 # 7 days for media
        client_ttl = 86400
        
        request_coalescing = true
        
        cache_key_policy = {
          include_query_string = false
        }
      }
      
      # Enable Cloud Armor for DDoS protection
      security_policy = "${local.env_vars.locals.environment}-${local.env_vars.locals.region}-security-policy"
    }
  }
  
  # Edge locations configuration
  edge_security_policy = {
    rules = [
      {
        priority = 1000
        action = "rate_based_ban"
        rate_limit_options = {
          rate_limit_threshold = {
            count = 100
            interval_sec = 60
          }
          ban_duration_sec = 600
        }
        description = "Rate limit rule"
      },
      {
        priority = 2000
        action = "deny(403)"
        match = {
          expr = {
            expression = "origin.region_code == 'XX'"
          }
        }
        description = "Block specific regions"
      }
    ]
  }
  
  labels = merge(
    local.common_vars.locals.common_labels,
    {
      component = "networking"
      resource  = "cdn"
    }
  )
}

resource "random_password" "cdn_key" {
  length  = 32
  special = false
}
```

## Enhanced GitHub Actions with Matrix Strategy

### Comprehensive CI/CD Pipeline
```yaml
# .github/workflows/terraform-ci-cd.yml

name: Terraform CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop
      - 'release/**'
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - plan
          - apply
          - destroy
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
      resource:
        description: 'Specific resource (optional, e.g., dev-us-central1-gke)'
        required: false
        type: string

env:
  TERRAFORM_VERSION: '1.5.0'
  TERRAGRUNT_VERSION: '0.50.0'
  TF_IN_AUTOMATION: true
  TF_INPUT: false

permissions:
  contents: read
  id-token: write
  pull-requests: write
  issues: write

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      environments: ${{ steps.set-matrix.outputs.environments }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Determine affected environments
        id: set-matrix
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Manual trigger - use specified environment
            ENVIRONMENTS='["${{ github.event.inputs.environment }}"]'
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # PR - check changed files
            CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | grep "^infrastructure/environments/" || true)
            if [[ -n "$CHANGED_FILES" ]]; then
              ENVIRONMENTS=$(echo "$CHANGED_FILES" | cut -d'/' -f3 | sort -u | jq -R -s -c 'split("\n")[:-1]')
            else
              ENVIRONMENTS='[]'
            fi
          else
            # Push to branch - determine environments based on branch
            if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
              ENVIRONMENTS='["prod"]'
            elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
              ENVIRONMENTS='["dev"]'
            elif [[ "${{ github.ref }}" == refs/heads/release/* ]]; then
              ENVIRONMENTS='["staging"]'
            else
              ENVIRONMENTS='["dev"]'
            fi
          fi
          
          echo "environments=${ENVIRONMENTS}" >> $GITHUB_OUTPUT
          
          # Create matrix for parallel execution
          if [[ "$ENVIRONMENTS" != '[]' ]]; then
            MATRIX=$(echo $ENVIRONMENTS | jq -c '{environment: .}')
          else
            MATRIX='{"environment":[]}'
          fi
          echo "matrix=${MATRIX}" >> $GITHUB_OUTPUT

  security-scan:
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.environments != '[]'
    steps:
      - uses: actions/checkout@v4
      
      - name: Run Checkov
        uses: bridgecrewio/checkov-action@master
        with:
          directory: infrastructure/
          framework: terraform
          output_format: sarif
          output_file_path: checkov.sarif
          skip_check: CKV_GCP_18,CKV_GCP_24
      
      - name: Upload SARIF file
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: checkov.sarif
      
      - name: Run tfsec
        uses: aquasecurity/tfsec-action@v1.0.3
        with:
          working_directory: infrastructure/
          format: sarif
          out: tfsec.sarif
      
      - name: Upload tfsec results
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: tfsec.sarif

  validate:
    runs-on: ubuntu-latest
    needs: [prepare, security-scan]
    if: needs.prepare.outputs.environments != '[]'
    strategy:
      matrix: ${{ fromJson(needs.prepare.outputs.matrix) }}
      fail-fast: false
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
      
      - name: Setup Terragrunt
        run: |
          wget -q https://github.com/gruntwork-io/terragrunt/releases/download/v${TERRAGRUNT_VERSION}/terragrunt_linux_amd64
          chmod +x terragrunt_linux_amd64
          sudo mv terragrunt_linux_amd64 /usr/local/bin/terragrunt
      
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets[format('GCP_SA_{0}', matrix.environment)] }}
      
      - name: Setup gcloud
        uses: google-github-actions/setup-gcloud@v2
      
      - name: Terragrunt Format Check
        run: |
          cd infrastructure/environments/${{ matrix.environment }}
          terragrunt hclfmt --terragrunt-check
      
      - name: Terragrunt Validate
        run: |
          cd infrastructure/environments/${{ matrix.environment }}
          if [[ -n "${{ github.event.inputs.resource }}" ]]; then
            terragrunt validate --terragrunt-working-dir ${{ github.event.inputs.resource }}.hcl
          else
            terragrunt run-all validate --terragrunt-non-interactive
          fi

  plan:
    runs-on: ubuntu-latest
    needs: [prepare, validate]
    if: needs.prepare.outputs.environments != '[]'
    strategy:
      matrix: ${{ fromJson(needs.prepare.outputs.matrix) }}
      fail-fast: false
    environment: ${{ matrix.environment }}-plan
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup tools
        uses: ./.github/actions/setup-tools
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terragrunt_version: ${{ env.TERRAGRUNT_VERSION }}
      
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets[format('GCP_SA_{0}', matrix.environment)] }}
      
      - name: Terragrunt Plan
        id: plan
        run: |
          cd infrastructure/environments/${{ matrix.environment }}
          
          if [[ -n "${{ github.event.inputs.resource }}" ]]; then
            terragrunt plan --terragrunt-working-dir ${{ github.event.inputs.resource }}.hcl \
              -out=tfplan \
              -lock=false
          else
            terragrunt run-all plan --terragrunt-non-interactive \
              -out=tfplan \
              -lock=false
          fi
      
      - name: Generate plan summary
        id: summary
        run: |
          cd infrastructure/environments/${{ matrix.environment }}
          
          # Extract plan summary
          if [[ -n "${{ github.event.inputs.resource }}" ]]; then
            PLAN_OUTPUT=$(terragrunt show --terragrunt-working-dir ${{ github.event.inputs.resource }}.hcl -no-color tfplan)
          else
            PLAN_OUTPUT=$(terragrunt run-all show --terragrunt-non-interactive -no-color tfplan)
          fi
          
          # Parse the plan output
          echo "plan<<EOF" >> $GITHUB_OUTPUT
          echo "$PLAN_OUTPUT" | grep -E "^(#|~|-|\+)" | head -50 >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Cost Estimation
        uses: infracost/actions/setup@v2
        with:
          api-key: ${{ secrets.INFRACOST_API_KEY }}
      
      - name: Generate Infracost report
        run: |
          cd infrastructure/environments/${{ matrix.environment }}
          infracost breakdown --path . \
            --format json \
            --out-file /tmp/infracost-${{ matrix.environment }}.json
      
      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const environment = '${{ matrix.environment }}';
            const planSummary = `${{ steps.summary.outputs.plan }}`;
            
            const comment = `## Terraform Plan - ${environment} 📋
            
            <details>
            <summary>Plan Summary</summary>
            
            \`\`\`diff
            ${planSummary}
            \`\`\`
            </details>
            
            **Environment:** ${environment}
            **Triggered by:** @${{ github.actor }}
            **Workflow:** ${{ github.workflow }}
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
      
      - name: Upload plan artifact
        uses: actions/upload-artifact@v3
        with:
          name: tfplan-${{ matrix.environment }}
          path: infrastructure/environments/${{ matrix.environment }}/**/tfplan
          retention-days: 7

  apply:
    runs-on: ubuntu-latest
    needs: [prepare, plan]
    if: |
      needs.prepare.outputs.environments != '[]' &&
      (github.ref == 'refs/heads/main' || 
       github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
    strategy:
      matrix: ${{ fromJson(needs.prepare.outputs.matrix) }}
      max-parallel: 1  # Apply one environment at a time
    environment: ${{ matrix.environment }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup tools
        uses: ./.github/actions/setup-tools
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terragrunt_version: ${{ env.TERRAGRUNT_VERSION }}
      
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets[format('GCP_SA_{0}', matrix.environment)] }}
      
      - name: Download plan artifact
        uses: actions/download-artifact@v3
        with:
          name: tfplan-${{ matrix.environment }}
          path: infrastructure/environments/${{ matrix.environment }}
      
      - name: Terragrunt Apply
        id: apply
        run: |
          cd infrastructure/environments/${{ matrix.environment }}
          
          if [[ -n "${{ github.event.inputs.resource }}" ]]; then
            terragrunt apply --terragrunt-working-dir ${{ github.event.inputs.resource }}.hcl \
              -auto-approve \
              -lock-timeout=10m
          else
            terragrunt run-all apply --terragrunt-non-interactive \
              --terragrunt-parallelism 2 \
              -auto-approve \
              -lock-timeout=10m
          fi
      
      - name: Deployment notification
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: |
            Deployment to ${{ matrix.environment }} ${{ job.status }}
            Environment: ${{ matrix.environment }}
            Triggered by: ${{ github.actor }}
            Commit: ${{ github.sha }}
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}

  destroy:
    runs-on: ubuntu-latest
    needs: prepare
    if: |
      github.event_name == 'workflow_dispatch' && 
      github.event.inputs.action == 'destroy' &&
      github.event.inputs.environment != 'prod'
    environment: ${{ github.event.inputs.environment }}-destroy
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup tools
        uses: ./.github/actions/setup-tools
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terragrunt_version: ${{ env.TERRAGRUNT_VERSION }}
      
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets[format('GCP_SA_{0}', github.event.inputs.environment)] }}
      
      - name: Terragrunt Destroy
        run: |
          cd infrastructure/environments/${{ github.event.inputs.environment }}
          
          if [[ -n "${{ github.event.inputs.resource }}" ]]; then
            terragrunt destroy --terragrunt-working-dir ${{ github.event.inputs.resource }}.hcl \
              -auto-approve \
              -lock-timeout=10m
          else
            # Destroy in reverse dependency order
            terragrunt run-all destroy --terragrunt-non-interactive \
              -auto-approve \
              -lock-timeout=10m
          fi

# Reusable action for tool setup
# .github/actions/setup-tools/action.yml
name: 'Setup Terraform Tools'
description: 'Setup Terraform and Terragrunt'
inputs:
  terraform_version:
    description: 'Terraform version'
    required: true
  terragrunt_version:
    description: 'Terragrunt version'
    required: true
runs:
  using: 'composite'
  steps:
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ inputs.terraform_version }}
        terraform_wrapper: false
    
    - name: Setup Terragrunt
      shell: bash
      run: |
        wget -q https://github.com/gruntwork-io/terragrunt/releases/download/v${{ inputs.terragrunt_version }}/terragrunt_linux_amd64
        chmod +x terragrunt_linux_amd64
        sudo mv terragrunt_linux_amd64 /usr/local/bin/terragrunt
    
    - name: Setup additional tools
      shell: bash
      run: |
        # Install gcloud
        echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | sudo tee -a /etc/apt/sources.list.d/google-cloud-sdk.list
        curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key --keyring /usr/share/keyrings/cloud.google.gpg add -
        sudo apt-get update && sudo apt-get install -y google-cloud-sdk
        
        # Install other useful tools
        sudo apt-get install -y jq yq
```

## Summary

This comprehensive implementation includes:

1. **Complete Module Implementations**:
   - App Engine (Standard & Flexible)
   - BigQuery with datasets, tables, and scheduled queries
   - Cloud Functions (Gen1 & Gen2)
   - Pub/Sub with schemas and subscriptions
   - Secret Manager with rotation and KMS integration
   - Load Balancer with advanced routing and CDN
   - CDN configuration with edge security

2. **Example Terragrunt Configurations**:
   - Detailed implementations for each service
   - Proper dependency management
   - Environment-specific configurations
   - Secret management integration

3. **Advanced CI/CD Pipeline**:
   - Matrix strategy for parallel execution
   - Security scanning (Checkov, tfsec)
   - Cost estimation with Infracost
   - Environment protection
   - Automated PR comments
   - Slack notifications
   - Artifact management
   - Reusable actions

The structure provides:
- **Production-ready** configurations
- **Security best practices** with secret management
- **Cost optimization** through environment-specific sizing
- **Comprehensive CI/CD** with multiple stages
- **Scalability** through modular design
- **Maintainability** with clear naming conventions